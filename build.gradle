buildscript {
	dependencies {
		classpath group: "com.liferay", name: "com.liferay.gradle.plugins.source.formatter", version: "5.1.10"
		classpath group: "com.liferay", name: "com.liferay.gradle.plugins.rest.builder", version: "1.0.36"
	}

	repositories {
		mavenCentral()
		maven {
			url "https://repository-cdn.liferay.com/nexus/content/groups/public"
		}
	}
}

plugins {
	id "org.sonarqube" version "3.3"
}

sonarqube {
	properties {
		property "sonar.projectKey", "rafoli_liferay-sample-workspace"
		property "sonar.organization", "rafoli"
		property "sonar.host.url", "https://sonarcloud.io"
	}
}

allprojects {
	plugins.withId("com.liferay.node") {
		afterEvaluate {
			node.download = true
			// Order is important; versions BEFORE invoking node.nodeUrl
			node.nodeVersion = "12.20.2"
			node.npmVersion = "6.14.11"
			node.nodeUrl = node.nodeUrl.replace("http:", "https:")
		}
	}
}

apply plugin: "com.liferay.source.formatter"

configure(subprojects.findAll { !it.subprojects }) {
	if (project.path.startsWith(":modules:")) {
		afterEvaluate { project ->
			checkSourceFormatting {
				maxLineLength = 120
			}

			formatSource {
				maxLineLength = 120
			}
		}
	}
}

subprojects { subproject ->
	sonarqube {
		properties {
			// This block of code is used to generate the coverage test data.
			if (subproject.pluginManager.hasPlugin('java')) {
				def tests = subproject.sourceSets.findAll { it.name.matches('test') }
				def testTasks = subproject.tasks.withType(Test.class)

				def testSources = tests.allJava.srcDirs.flatten().findAll { it.exists() }
				def testClasses = tests.output.classesDirs.files.flatten().findAll { it.exists() }
				def junitReports = testTasks.collect {it.reports.junitXml.destination.exists()?it.reports.junitXml.destination:null  }.find { it != null}
				def jacocoReports = fileTree(subproject.projectDir).include("**/build/jacoco/*.exec").files
				//find files that will be excluded by content
				def generatedFiles = fileTree(subproject.projectDir).include("**/*.java")
						.files.findAll {
					it.text.contains("* @generated") ||
							it.text.contains("This file was generated by the JavaTM Architecture") ||
							it.text.contains("NOTE FOR DEVELOPERS:")
				}
						.collect { subproject.relativePath(it) }
				def exceptionFiles = fileTree(subproject.projectDir).include("**/*Exception.java")
						.files.findAll { it.exists() }
						.collect { subproject.relativePath(it) }

				property 'sonar.tests', testSources
				property 'sonar.java.test.binaries', testClasses
				property 'sonar.junit.reportPaths', junitReports
				property 'sonar.jacoco.reportPaths', jacocoReports
				property "sonar.coverage.exclusions", generatedFiles
				property "sonar.exclusions", generatedFiles
			}
			else if (subproject.pluginManager.hasPlugin('com.liferay.node')) {

				def typescriptSources = fileTree(subproject.projectDir).include("**/*.ts").files.flatten().findAll { it.exists() }
				def typescriptSpecSources = fileTree(subproject.projectDir).include("**/*.spec.ts").files.flatten().findAll { it.exists() }
				def javascriptReports = fileTree(subproject.projectDir).include("**/report/lcov.info").files

				property 'sonar.sources', typescriptSources - typescriptSpecSources
				property 'sonar.tests', typescriptSpecSources
				property 'sonar.typescript.lcov.reportPaths', javascriptReports
				property 'sonar.typescript.exclusions', "**/node_modules/**, **/bower_components/**, **/lib/**"
			}
		}
	}
}
